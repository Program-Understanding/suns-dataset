#! /bin/bash
echo "This is a proof of concept script that runs a docker container that we feed our example to"
echo "You must build the container separate from running the analyses"
declare -A map_of_tool_names_to_questions_and_scripts

start_tool() {

    #e.g.,
    #docker stop running-ghidra-xrefs-tool
    #docker rm running-ghidra-xrefs-tool
    #docker create --name running-ghidra-xrefs-tool ghidra-xrefs-tool
    #docker ps -a | grep running-ghidra-xrefs-tool
    #docker start running-ghidra-xrefs-tool
    
    local tool=$1
    docker stop "running-$tool-tool"
    docker rm "running-$tool-tool"
    docker create --name "running-$tool-tool" "$tool-tool"
    docker ps -a | grep "running-$tool-tool"
    docker start "running-$tool-tool"
}

stop_tool() {
    docker stop "running-$tool-tool"
    docker rm "running-$tool-tool"
}

process_cfr_file() {

    local json_file="$1"  # Get the first argument passed to the function
    local tool="$2"
    local SCRIPT="$3"
    
    echo "this is the file to process:$json_file"
    echo "this is the tool:$tool"
    echo "this is the script before any substitutions:$SCRIPT"

    #TODOconsider having only a single parent directory???
    CFR_JSON_PATH=$(dirname "$json_file")
    CFR_JSON_FILENAME=$(basename "$json_file")
    BINARY_TO_ANALYZE_PATH=$(dirname "$json_file")
    BINARY_TO_ANALYZE_FILENAME=$(jq -r '.program' $json_file)


    #we use "-r" because we don't want the double blackslash that we had to have in our JSON to get a backslash
    #we should look for the <tool>-cfrs.json file
    #SCRIPT=$(jq -r '.script' $CFR_JSON_PATH/$CFR_JSON_FILENAME )

    #assuming there is no "crfs" file, then we use the script associated with the question
    #if [ "$SCRIPT" = "null" ]; then
	#echo "no script found"
	#SCRIPT= "script": "/ghidra/ghidra_11.2_PUBLIC/support/analyzeHeadless /control-flow-recovery project -import $BINARY_TO_ANALYZE_FILENAME -scriptPath /control-flow-recovery -postscript ReportXrefs.java $CFR_JSON_FILENAME -overwrite",

    #fi
    
    #use binary expansion to allow scripts to use the predefined environment variables

    SCRIPT="${SCRIPT//\$BINARY_TO_ANALYZE_FILENAME/$BINARY_TO_ANALYZE_FILENAME}"
    SCRIPT="${SCRIPT//\$BINARY_TO_ANALYZE_PATH/$BINARY_TO_ANALYZE_PATH}"
    SCRIPT="${SCRIPT//\$CFR_JSON_PATH/$CFR_JSON_PATH}"
    SCRIPT="${SCRIPT//\$CFR_JSON_FILENAME/$CFR_JSON_FILENAME}"

    echo "The script  is:$SCRIPT"

    docker cp "$BINARY_TO_ANALYZE_PATH/$BINARY_TO_ANALYZE_FILENAME" running-ghidra-xrefs-tool:/control-flow-recovery/$BINARY_TO_ANALYZE_FILENAME
    docker cp $json_file running-ghidra-xrefs-tool:/control-flow-recovery/$CFR_JSON_FILENAME

    docker ps -a | grep running-ghidra-xrefs-tool

    docker exec running-ghidra-xrefs-tool /bin/bash -c "ls"

    LOGFILE="$(basename $CFR_JSON_PATH)-log"
    RESULTFILE="$(basename $CFR_JSON_PATH)-results"
    
    docker exec running-ghidra-xrefs-tool /bin/bash -c "$SCRIPT" > results/$LOGFILE

    #now search the log file
    grep "RESULTS:" results/$LOGFILE > results/$RESULTFILE
    
    docker exec running-ghidra-xrefs-tool /bin/bash -c "rm $BINARY_TO_ANALYZE_FILENAME"
    docker exec running-ghidra-xrefs-tool /bin/bash -c "rm $CFR_JSON_FILENAME"
    docker exec running-ghidra-xrefs-tool /bin/bash -c "ls"

}

get_questions_for_tool() {
    #these special keywords can appear in questions, e.g., $INSTRUCTION or $OFFSET
    INSTRUCTION="(.*)"
    OFFSET="(0[xX][0-9a-fA-F]+|[0-9]+)"
    #echo "Here is our argument:$1"
    local questions_array=$(jq -r '.questions[].question' $1/questions.json)
    local transformed_questions=()
    for question in "${questions_array[@]}"; do
	#echo "here is the question:$question"
	transformed_question="${question//\$INSTRUCTION/$INSTRUCTION}"
	transformed_question="${transformed_question//\$OFFSET/$OFFSET}"
	#echo "here is a transformed question:$transformed_question"
	transformed_questions+=($transformed_question)
    done

    echo "${transformed_questions[@]}"
}


get_scripts_for_tool() {
    #transformations on scripts happen when we read the cfr file
    local scripts_array=$(jq -r '.questions[].script' $1/questions.json)
    echo "${scripts_array[@]}"
}


#for efficiency reasons, we try to apply each tool to each dataset
find ./tools/* -type d | while read -r tooldir; do
    echo "found a tool directory: $tooldir"

    #get_questions_for_tool "$tooldir"
    questions=$(get_questions_for_tool "$tooldir")
    echo "here are the questions:$questions"
    scripts=$(get_scripts_for_tool "$tooldir")
    echo "here are the scripts:$scripts"

    #extract the name of the tool from the tooldir
    tool="${tooldir##*/}"
    echo "here is the name of the tool:$tool"
    #start the tool

    start_tool $tool
    
    #iterate over the datasets

    find .. -type d | while read -r dir; do
    	echo "processing directory: $dir"
    	json_files=$(find "$dir" -maxdepth 1 -type f -name "*cfr.json")
	if [ -n "$json_files" ]; then
	       while read -r json_file; do
		   cfr_question=$(jq -r '.question' $json_file )
		   length=${#questions[@]}
		   for (( i=0; i<length; i++ )); do
		       question=${questions[i]}
		       script=${scripts[i]}
		       if [[ $question =~ $cfr_question ]]; then
			   echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!Found a file to process: $json_file"
			   #probably we send the name of the tool to the process command??>
			   #TODO...do we passs the tooldir or the tool name?
			   process_cfr_file "$json_file" "$tooldir" "script"
		       fi
		   done
	       done
	fi
    done

    stop_tool $dir

done


