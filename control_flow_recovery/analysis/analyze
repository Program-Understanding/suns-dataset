#! /bin/bash

#Doing this without the use of these two globals became quite a pain, so I gave up
questions_for_tool=()
scripts_for_tool=()
log_processing_scripts_for_tool=()
only_tool="*all*"
only_cfr="*all*"
only_new=false

function show_help {
    echo "Usage: $0 [OPTIONS]"
    echo ""
    echo "Options:"
    echo "  --only_tool TOOL    Specify a tool to run (default is all)."
    echo "  --only_cfr CFR      Specify a cfr to analyze (default is all)."
    echo "     CFR is either path, filename, or filename without '-cfr.json' " 
    echo "  --only_new          If set, only run analysis that are likely new"
    echo "  --help          Display this help message."
    echo "CURRENT STATUS:  only_new is not yet functional!!!!!"
}

start_tool() {
    local tool=$1
    docker stop "running-$tool-tool" 2> /dev/null
    docker rm "running-$tool-tool" 2> /dev/null
    docker create --name "running-$tool-tool" "$tool-tool" > /dev/null
    #docker ps -a | grep "running-$tool-tool"
    docker start "running-$tool-tool" > /dev/null
}

stop_tool() {
    local tool=$1
    docker stop "running-$tool-tool" 2> /dev/null
    docker rm "running-$tool-tool" 2> /dev/null
}

process_cfr_file() {

    local json_file="$1"  # Get the first argument passed to the function
    local tool="$2"
    local SCRIPT="$3"
    local tooldir="$4" 
    local LOG_PROCESSING_SCRIPT="$5"
    
    echo "    processing $json_file using tool $tool"
    #echo "    this is the file to process:$json_file"
    #echo "    this is the tool:$tool"
    #echo "    this is the script before any substitutions:$SCRIPT"
    #echo "    this is the tooldir:$tooldir"

    CFR_JSON_PATH=$(dirname "$json_file")
    CFR_JSON_FILENAME=$(basename "$json_file")
    BINARY_TO_ANALYZE_PATH=$(dirname "$json_file")
    BINARY_TO_ANALYZE_FILENAME=$(jq -r '.program' $json_file)

    #we use "-r" because we don't want the double blackslash that we had to have in our JSON to get a backslash
    #we should look for the <tool>-cfrs.json file
    #SCRIPT=$(jq -r '.script' $CFR_JSON_PATH/$CFR_JSON_FILENAME )

    #assuming there is no "crfs" file, then we use the script associated with the question
    #if [ "$SCRIPT" = "null" ]; then
	#echo "no script found"
	#SCRIPT= "script": "/ghidra/ghidra_11.2_PUBLIC/support/analyzeHeadless /control-flow-recovery project -import $BINARY_TO_ANALYZE_FILENAME -scriptPath /control-flow-recovery -postscript ReportXrefs.java $CFR_JSON_FILENAME -overwrite",

    #fi
    
    #use binary expansion to allow scripts to use the predefined environment variables

    SCRIPT="${SCRIPT//\$BINARY_TO_ANALYZE_FILENAME/$BINARY_TO_ANALYZE_FILENAME}"
    SCRIPT="${SCRIPT//\$BINARY_TO_ANALYZE_PATH/$BINARY_TO_ANALYZE_PATH}"
    SCRIPT="${SCRIPT//\$CFR_JSON_PATH/$CFR_JSON_PATH}"
    SCRIPT="${SCRIPT//\$CFR_JSON_FILENAME/$CFR_JSON_FILENAME}"

    echo "    The script is:$SCRIPT"
    
    docker cp "$BINARY_TO_ANALYZE_PATH/$BINARY_TO_ANALYZE_FILENAME" "running-$tool-tool:/control-flow-recovery/$BINARY_TO_ANALYZE_FILENAME"
    docker cp "$json_file" "running-$tool-tool:/control-flow-recovery/$CFR_JSON_FILENAME"

    #docker ps -a | grep "running-$tool-tool"

    #consider providing flags to analyze to do more debuggin like this?
    #docker exec "running-$tool-tool" /bin/bash -c "ls"

    #LOGFILE="$(basename $CFR_JSON_PATH)-log"
    #RESULTFILE="$(basename $CFR_JSON_PATH)-results"

    RPATH="${CFR_JSON_PATH/../results}"
    if [ ! -d "$RPATH" ]; then
	mkdir -p "$RPATH"
    fi

    CFR_MODIFIED="${CFR_JSON_FILENAME/cfr.json/$tool}"
    
    LOGFILE="$RPATH/$CFR_MODIFIED-log"
    RESULTFILE="$RPATH/$CFR_MODIFIED-results"    

    docker exec "running-$tool-tool" /bin/bash -c "$SCRIPT" > $LOGFILE 2>&1

    # replace tooldir/logfile argument in log script
    # these substitutions are different because they are occuring on the host, not the docker image
    LOG_PROCESSING_SCRIPT="${LOG_PROCESSING_SCRIPT//\$BINARY_TO_ANALYZE_FILENAME/$BINARY_TO_ANALYZE_PATH\/$BINARY_TO_ANALYZE_FILENAME}"
    LOG_PROCESSING_SCRIPT="${LOG_PROCESSING_SCRIPT//\$BINARY_TO_ANALYZE_PATH/$BINARY_TO_ANALYZE_PATH}"
    LOG_PROCESSING_SCRIPT="${LOG_PROCESSING_SCRIPT//\$CFR_JSON_PATH/$CFR_JSON_PATH}"
    LOG_PROCESSING_SCRIPT="${LOG_PROCESSING_SCRIPT//\$CFR_JSON_FILENAME/$json_file}"
    LOG_PROCESSING_SCRIPT="${LOG_PROCESSING_SCRIPT//\$LOG_FILENAME/$LOGFILE}"
    LOG_PROCESSING_SCRIPT="${LOG_PROCESSING_SCRIPT//\$TOOL_DIR/$tooldir}"

    #echo "log process script: $LOG_PROCESSING_SCRIPT"
    # run log processing, if it exists
    if [[ "$LOG_PROCESSING_SCRIPT" == "null" ]]; then
	#if not just search the log file
	grep "RESULTS:" $LOGFILE > $RESULTFILE
	#echo "side 1"
    else
	$LOG_PROCESSING_SCRIPT > $RESULTFILE
	#echo "side 2"
    fi
    
    docker exec "running-$tool-tool" /bin/bash -c "rm $BINARY_TO_ANALYZE_FILENAME" 
    docker exec "running-$tool-tool" /bin/bash -c "rm $CFR_JSON_FILENAME"
    #docker exec "running-$tool-tool" /bin/bash -c "ls"

}

get_questions_for_tool() {
    #these special keywords can appear in questions, e.g., $INSTRUCTION or $OFFSET
    local INSTRUCTION="(.*)"
    local OFFSET="(0[xX][0-9a-fA-F]+|[0-9]+)"
    #echo "Here is our argument:$1"
    # Use jq to extract the questions and read them into the array

    local json_data=$(<$1/questions.json)
    # Initialize an empty array
    local questions=()

    # Use jq to extract the questions and read them into the array
    while IFS= read -r question; do
	questions+=("$question")
    done < <(echo "$json_data" | jq -r '.questions[].question')

    # Print the length of the array
    #length=${#questions[@]}
    #echo "Length of the array: $length"

    questions_for_tool=() #clear the global

    for question in "${questions[@]}"; do

	local transformed_question="${question//\$INSTRUCTION/$INSTRUCTION}"
	local transformed_question="${transformed_question//\$OFFSET/$OFFSET}"
	#echo "    here is the transformed question:$transformed_question"
	questions_for_tool+=("$transformed_question")
    done

}


get_scripts_for_tool() {
    #transformations on scripts happen when we read the cfr file
    json_data=$(<$1/questions.json)
    # Initialize an empty array
    scripts=()
    log_processing_scripts=()
    # Use jq to extract the scripts and read them into the array
    while IFS= read -r script; do
	scripts+=("$script")
    done < <(echo "$json_data" | jq -r '.questions[].script')
    while IFS= read -r script; do
	log_processing_scripts+=("$script")
    done < <(echo "$json_data" | jq -r '.questions[].processLogScript')

    scripts_for_tool=() #clear the global
    log_processing_scripts_for_tool=() #clear the global

    for script in "${scripts[@]}"; do
	#echo "    here is the script:$script"
        scripts_for_tool+=("$script")
    done
    for script in "${log_processing_scripts[@]}"; do
	#echo "    here is the script2:$script"
        log_processing_scripts_for_tool+=("$script")
    done

}


filter_cfr_files() {

    local input_list="$1"
    local filtered_list=""

    # Iterate over each line in the input list
    while IFS= read -r line; do
        # Check if the line is not "blah"

	
        if [[ "$only_cfr" == *"/"* ]]; then
	    #if user specified a path, match exact
	    if [[ "$line" == "$only_cfr" ]]; then
		filtered_list+="$line"$'\n'
	    fi
	else
	    if [[ $(basename "$line") == "$only_cfr" ]]; then
		filtered_list+="$line"$'\n'
	    fi
	    if [[ $(basename "$line") == "$only_cfr-cfr.json" ]]; then
		filtered_list+="$line"$'\n'
	    fi
	fi

	#if [[ "$line" != "blah" ]]; then
        #    filtered_list+="$line"$'\n'
        #fi
    done <<< "$input_list"

    # Remove the trailing newline character
    filtered_list="${filtered_list%$'\n'}"

    echo "$filtered_list"
}





#process command line arguments
while [[ "$#" -gt 0 ]]; do
    case "$1" in
        --only_tool)
            if [[ -n "$2" && ! "$2" =~ ^-- ]]; then
                only_tool="$2"
                shift 2
            else
                echo "Error: --only_tool requires a tool name."
                exit 1
            fi
            ;;
        --only_cfr)
            if [[ -n "$2" && ! "$2" =~ ^-- ]]; then
                only_cfr="$2"
                shift 2
            else
                echo "Error: --only_cfr requires a cfr file specification."
                exit 1
            fi
            ;;
        --only_new)
            only_new=true
            shift
            ;;
        --help)
            show_help
            exit 0
            ;;
        --*)
            echo "Unknown option: $1"
            show_help
            exit 1
            ;;
        *)
            echo "Analyze takes options, but no positional arguments such as: $1"
            show_help
            exit 1
            ;;
    esac
done

#echo "only_tool $only_tool"
#echo "only_cfr $only_cfr"
#echo "only_new $only_new"

echo "This is a proof of concept script that runs a docker container that we feed our example to"
echo "You must build the container separate from running the analyses"




#for efficiency reasons, we try to apply each tool to each dataset
find ./tools/*  -maxdepth 0 -type d | while read -r tooldir; do
    echo "found a tool directory: $tooldir"
    #extract the name of the tool from the tooldir
    tool="${tooldir##*/}"
    #echo "    here is the name of the tool:$tool"

    if [ -f $tooldir/.ignoreme ]; then
        echo "Ignoring this directory (there is a .ignoreme file in $tooldir)"
        continue
    fi

    if [[ $only_tool != "*all*" && $tool != "$only_tool" ]]; then
	continue
    fi
    
    get_questions_for_tool "$tooldir"
    #echo "    There are ${#questions_for_tool[@]} questions"
    get_scripts_for_tool "$tooldir"
    #echo "    There are ${#scripts_for_tool[@]} scripts"
    #start the tool

    start_tool $tool
    
    #iterate over the datasets
    
    find .. -type d | while read -r dir; do
	if [ "$dir" == "../analysis" ]; then
	    continue #skip the analysis directory
	fi

	if [[ "$dir" == ../analysis/* ]]; then
	    continue #skip all of the subdirectories in analysis
	fi

    	#echo "processing directory: $dir"
    	cfr_json_files=$(find "$dir" -maxdepth 1 -type f -name "*cfr.json")
	#echo "Here are the json files: $cfr_json_files"

	if [[ $only_cfr != "*all*" ]]; then
	    cfr_json_files=$(filter_cfr_files "$cfr_json_files")
	fi

	if [ -n "$cfr_json_files" ]; then
	    echo "$cfr_json_files" | while read -r cfr_json_file; do
		echo "fetching question from $cfr_json_file"
		cfr_question=$(jq -r '.question' "$cfr_json_file" )
		#echo "here is the question:$cfr_question"
		length=${#questions_for_tool[@]}
		#echo "There are $length questions to compare against"
		for (( i=0; i<length; i++ )); do
		    question=${questions_for_tool[i]}
		    #echo "here is the regex #$i we are comparing to:$question"
		    if [[ $cfr_question =~ $question ]]; then
			#echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!Found a file to process: $cfr_json_file"
			script=${scripts_for_tool[i]}
			log_script=${log_processing_scripts_for_tool[i]}
			process_cfr_file "$cfr_json_file" "$tool" "$script" "$tooldir" "$log_script"
		    fi
		done
	    done
	fi
    done

    stop_tool $tool

done


